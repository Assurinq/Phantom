FORMAT: 1A
HOST: http://polls.apiblueprint.org/

# Phantom

![](https://raw.githubusercontent.com/cyberpwnn/Phantom/master/phantom-medium.png)

The phantom api is an api designed to allow plugin developers to program structured, fast plugins with speed by abstracting common things usually needed for most plugins. The biggest part of Phantom is the Controller system, and the Data-clusters with Configurable objects. To get started working with phantom, find what you need below.

# Controllers
###### The Simplest structure of a Phantom Plugin

Phantom plugins are designed by controllers. Controllers are very simple and nature, yet can be extremley powerful if used correctly. Here is the basic model of a controller

## Controller Structure

Controllers are structured as shown above. A controller is a generic interface used for controlling objects sort of like "sub-plugins". A controller has several attirbutes.

* A controller can belong to a parent controller \(plugin, controller, or null if is plugin\)
* A Controller can contain sub controllers which are started before the current controller is
* A Controller can start, and stop
* A Controller can also reload, restarting all of its subcontrollers along with itself
* A Controller can also be ticked with the @Ticked annotation 

# Phantom Plugins
###### The base plugin class and how it is wrapped

Phantom plugins simply wrap the controller's ability to do what a controller should do, along with the ability of being a plugin. Its simply explained with this diagram

## Explanation of Execution

Essentially the reason why there are two enables and disables is because you need to register sub-controllers somewhere, and since java plugins are initialized elsewhere, the enable is designed to register controllers. The onStart\(\) is designed to be called when all your sub controllers \(and their sub controllers\) have been started. The root controller is the last to be "started".

**NOTE: DO NOT USE onEnable\(\) or onDisable\(\). Use enable\(\) and disable\(\)**

# Creating the Plugin

![](http://i.imgur.com/PRlT31K.png)

When creating the phantom plugin, you only need to have 3 things for it to be valid

``` java
package org.phantomapi.example;

import org.phantomapi.construct.PhantomPlugin;

public class ExamplePlugin extends PhantomPlugin
{
    @Override
    public void enable()
    {
        
    }

    @Override
    public void disable()
    {
        
    }
}
```

## Ghost Plugin
For finer events, use the Ghost plugin as your base instead of PhantomPlugin

``` java
package org.phantomapi;

import org.phantomapi.construct.Ghost;

public class ExamplePlugin extends Ghost
{
    @Override
    public void preStart()
    {
        //This is effectivley the onEnable()
        //Use this to init and register configs
    }

    @Override
    public void onStart()
    {
        //This is called when all your controllers have started
        //Use this to load configs just like controllers
    }

    @Override
    public void onStop()
    {
        //This is called when all of your controllers have stopped
    }

    @Override
    public void postStop()
    {
        //This is the last thing called before disable
    }
}

```

# Using Controllers
###### Nest controllers in other controllers

Controllers are very simple to use when structuring a plugin or adding additional plugins. To add a controller to our example plugin, let's create a basic controller first.

## The Controller
Since this controller can be initialized via constructor, all sub-controllers of this controller do not need to be created in an enable method. You can simply initialize them in the constructor. To create a controller, you will need the following
* Extend Controller
* onStart()
* onStop()

``` java
package org.phantomapi.example;

import org.phantomapi.construct.Controllable;
import org.phantomapi.construct.Controller;

public class ExampleController extends Controller
{
    public ExampleController(Controllable parentController)
    {
        super(parentController);
    }

    @Override
    public void onStart()
    {
        
    }

    @Override
    public void onStop()
    {
        
    }
}
```

Now that we have the controller, we can now use it in our example plugin.

## Registering the Controller
Back to our basic plugin example, we can add the controller in three steps.
* Reference the controller in a field
* Initialize the controller passing the parent ("this" plugin)
* Register the controller

``` java
package org.phantomapi.example;

import org.phantomapi.construct.PhantomPlugin;

public class ExamplePlugin extends PhantomPlugin
{
    private ExampleController exampleController;
    
    @Override
    public void enable()
    {
        exampleController = new ExampleController(this);
        
        register(exampleController);
    }

    @Override
    public void disable()
    {
        
    }
}
```

Now that the controller has been registered, the ExampleController instance will fire onStart() before the plugin invokes onStart(). This goes the same with the onStop(). This ensures that if any controller is started, it can be assured that all of its sub controllers are already started.

# Ticking Controllers
###### Controllers can be ticked
Controllers have an onTick method, however they are disabled by default in controllers that do not define that they can be ticked. This is due to very obvious performance reasons.
## Ticking a Controller
To tick a controller, you really only need to add 2 things.
* @Ticked(delay) annotation
* onTick() method

``` java
package org.phantomapi.example;

import org.phantomapi.construct.Controllable;
import org.phantomapi.construct.Controller;
import org.phantomapi.construct.Ticked;

@Ticked(0)
public class ExampleController extends Controller
{
    public ExampleController(Controllable parentController)
    {
        super(parentController);
    }

    @Override
    public void onStart()
    {
        
    }

    @Override
    public void onStop()
    {
        
    }
    
    @Override
    public void onTick()
    {
        
    }
}
```
As you can see in the current example, we have defined the ticked annotation as ```@Ticked(0)```. This tells the phantom provider that this controller needs to be ticked with 0 delay (1 does the same thing as 0). This means that this controller will be ticked 20 times a second. However if you were to define ```@Ticked(200)``` the controller would tick every 10 seconds.

# Dispatching log information
###### Async Safe, Colorful, Useful
Logging is very simple within a controller, and allows for very quick additions and removals, along with color coded channels for logging. Each controller has a dispatcher instance within it allowing each controller dispatcher to have a different tag. 

Dispatcher tags are defined by the controller backed by all the super controllers behind it. So in our ExampleController example, the tag or even toString() would return something like this.```ExamplePlugin > ExampleController```

## Using the Dispatcher in Controllers
By default, all controllers inherit dispatcher methods, so the instance is behind the methods.

``` java
i("Info! (White. Not Gray.)");
s("Success! (Green)");
w("WARNING! (Yellow)");
f("FAILURE! (Red)");
v("Verbose! (Light Purple)");
o("OVERBOSE! (Aqua)");
```

## Creating a Dispatcher instance
You can also create a dispatcher instance very simply and use it wherever you like with whatever tag you need.
``` java
D d = new D("Custom Tag");

d.i("Info! (White. Not Gray.)");
d.s("Success! (Green)");
d.w("WARNING! (Yellow)");
d.f("FAILURE! (Red)");
d.v("Verbose! (Light Purple)");
d.o("OVERBOSE! (Aqua)");
```

# Controller Messages
###### Talk to other controllers without reflection

Controllers can send packs of data between each other cross controller cross plugin without the classpath of the plugin with that controller. You just need to know the name

![](Capturexd.PNG)

## Sending a Controller Message
This creates a message and sends the message getting a response in return. This response will either contain more data, changed data, or the same data cluster if the controller diddnt return anything extra.

``` java
//Create a message (it's a data cluster)
ControllerMessage msg = new ControllerMessage(this);
msg.set("is", "loaded"); //Key Val string to ask if the other controller is loading

//Send the message
ControllerMessage response = sendMessage("TheController", msg);

if(response.contains("result", ClusterDataType.BOOLEAN))
{
    boolean loaded = response.getBoolean("result");
}
```

## Listening for Controller Messages
Here we can listen for controller messages. Never Return null. If you dont want to return data, simply return the message.

``` java
//We override this in a controller
@Override
public ControllerMessage onControllerMessageRecieved(ControllerMessage message)
{
    //We do a safe check
    if(message.contains("is", ClusterDataType.STRING))
    {
        //And check if the is is equal to loaded
        if(message.getString("is").equalsIgnoreCase("loaded"))
        {
            //We will just respond true every time
            message.set("result", true);
        }
    }
    
    //Always return the message
    return message;
}
```

# Placeholders
###### No need to hook into placeholderapi
You can register placeholers to placeholderapi without depending on the placeholderapi, since phantom depends on it, you can hook in through phantom instead.

## Create the Placeholder Hook

``` java
package org.phantomapi;

import org.bukkit.entity.Player;
import org.phantomapi.placeholder.PlaceholderHook;

public class DummyPlaceholderHook extends PlaceholderHook
{
    @Override
    public String onPlaceholderRequest(Player p, String q)
    {
        if(q.equalsIgnoreCase("name"))
        {
            return p.getDisplayName();
        }
        
        return null;
    }
}

```

## Register it

``` java
new DummyPlaceholderHook().hook();
```

You can parse them also

``` java
PlaceholderUtil.handle(Player, String);
```

# Data Clusters
###### Where data is stored and manipulated for many applications.
Data Clusters are simply a mapping of keys and values with the ability to store comments and manipulate them in many ways. Here is the basic usage of data clusters.

``` java
//Create a new DataCluster
DataCluster cc = new DataCluster();

//Set some data
cc.set("some.key.1", false);
cc.set("some.key.2", "a string");
cc.set("some.key.3", 123123123);
cc.set("some.key.4", 3453453454323423423l);
cc.set("some.key.5", 3.5454545454545454545);
cc.set("some.key.6", new GList<String>(new String[]{"String", "List"}));

//Crop the DataCluster
DataCluster cropped = cc.crop("some.key");
cropped.getBoolean("1");
cropped.getString("2");
cropped.getInt("3");
cropped.getLong("4");
cropped.getDouble("5");
cropped.getStringList("6");

//Output
JSONObject s = cc.toJSON();
FileConfiguration fc = cc.toYaml();

//Add
cc.addJson(new JSONObject("{'some.key.7': 'foobar'}"));
```

By themselves, they are very useful, however they can do so much more with the help of configurable objects.

# 2.2 Configurable Objects
###### Objects can be configurable with data clusters
Configurable objects allow you to simply make any object configurable. This means you can load and save data from the object in a config design as you like. 

![](687474703a2f2f692e696d6775722e636f6d2f586176583657572e706e67.png)

As you can see, the data cluster plays a big part and actually holding the data, while the configurable object uses it and is controlled by a loader or saving instance.

## Basic Configurable Objects
Basic configurable objects rely on the onNewConfig() and onSaveConfig() To do this, we need to do a few things.
* Implement org.phantomapi.clust.Configurable
* Handle the onNewConfig();

``` java
package org.phantomapi.example;

import org.phantomapi.clust.Configurable;
import org.phantomapi.clust.DataCluster;

public class ExampleConfigurable implements Configurable
{
    //Define the cluster
    private DataCluster cc;
    
    public ExampleConfigurable()
    {
        //Create a new cluster for this instance
        cc = new DataCluster();
    }
    
    @Override
    public void onNewConfig()
    {
        //Here is where we structure DEFAULTS for the config
        cc.set("something.enabled", true, "Optional\nMultiline\nComment");
        cc.set("something.name", "Configurable Name");
    }

    @Override
    public void onReadConfig()
    {
        //Called when the dataCluster has been updated with the remote
    }

    @Override
    public DataCluster getConfiguration()
    {
        //This is needed for any requests to handle this configuration object
        return cc;
    }

    @Override
    public String getCodeName()
    {
        //This is the name of the file,
        //NOT THE LOCATION
        //NOT THE EXTENSION
        return "config";
    }
    
}
```

### Loading the Configuration
Loading the configuration is actually a little bit more than simply reading the config into the data cluster. Since we cannot assume what the file contains and if its YAML, or if its a folder, all of the configuration handlers deal with that. Here is the basic logic path of the configuration handlers
* Create the file if it does not exist
* Write all of your onNewconfig default data to a cache cluster
* Read all of the data into the cache cluster (overwrites any defaults)
* Saves all of the data from the cache cluster to the file

The beauty of this, is your config can have new values anytime, and it flawlessly updates. If the user were to delete a few nodes in the config, no problem. Your data cluster in the memory is used to actually use that data, but more importantly, since the defaults are overwritten, those values wont, meaning the user will get default values back for just those nodes.

``` java
package org.phantomapi.example;

import org.phantomapi.construct.Controllable;
import org.phantomapi.construct.Controller;
import org.phantomapi.construct.Ticked;

@Ticked(0)
public class ExampleController extends Controller
{
    public ExampleController(Controllable parentController)
    {
        super(parentController);
        
        // Create an instance of it
        ExampleConfigurable e = new ExampleConfigurable();
        loadCluster(e);
        // The configuration has been loaded.
        e.getConfiguration().getBoolean("something.enabled");
    }
    
    @Override
    public void onStart()
    {
        
    }
    
    @Override
    public void onStop()
    {
        
    }
    
    @Override
    public void onTick()
    {
        
    }
}
```

## Field Configuration
Instead of using the data cluster to read and add values from the onNewconfig, we can use reflection instead! However this is handled by phantom with the use of annotations. In this example, we're going to make a controller configurable instead of using it in another object.
* Define Fields
 * Must be PUBLIC
 * Must have an initial VALUE
 * Must have an @Keyed("path.in.yml")
 * Optional to have an @Comment("comment")
* No need to use the onNewConfig or onReadConfig methods
* Fields are read and modified via reflection

``` java
package org.phantomapi.example;

import org.phantomapi.clust.Comment;
import org.phantomapi.clust.Configurable;
import org.phantomapi.clust.DataCluster;
import org.phantomapi.clust.Keyed;
import org.phantomapi.construct.Controllable;
import org.phantomapi.construct.Controller;
import org.phantomapi.construct.Ticked;

@Ticked(0)
public class ExampleController extends Controller implements Configurable
{
    //Define it as PUBLIC and fill in the value
    @Keyed("some.name")
    public String someName = "Some Value";
    
    //Comment your fields
    @Comment("This is a \nMultiline Comment")
    @Keyed("some.value")
    public int someVal = 665;
    
    @Comment("Wrappers can be used aswell")
    @Keyed("some.wrapper")
    public Double someWrapper = 3.54543452;
    
    private DataCluster cc;
    
    public ExampleController(Controllable parentController)
    {
        super(parentController);
        
        cc = new DataCluster();
    }
    
    @Override
    public void onStart()
    {
        //Useful for loading in the plugin root 
        loadCluster(this);
        
        //Loads this with Plugin/folder/<code-name>.yml
        loadCluster(this, "folder");
    }
    
    @Override
    public void onStop()
    {
        
    }
    
    @Override
    public void onTick()
    {
        
    }

    @Override
    public void onNewConfig()
    {
        // Dynamic (not using it)
    }

    @Override
    public void onReadConfig()
    {
        // Dynamic (not using it)
    }

    @Override
    public DataCluster getConfiguration()
    {
        return cc;
    }

    @Override
    public String getCodeName()
    {
        return "config";
    }
}
```

## Using MySQL Instead of YAML
Using MySQL is actually very simple since most of the information is pretty much all phantom needs. We just need to annotate our "table" and change how we load and save our data.
* MySQL tables can change dynamically, JSON is used instead of raw data
* MySQL loading does NOT put in defaults. You need to save after your done with it

Look at the @Tabled annotation right above the object TYPE, and look in the onStart method. Thats all you need.

MySQL is connected when either you define that you require mysql or when you try to use it. The actual database authentication is inside of the Phantom/mysql.yml configuration. This allows all phantom plugins not need to deal with connections.

``` java
package org.phantomapi.example;

import org.phantomapi.clust.Comment;
import org.phantomapi.clust.Configurable;
import org.phantomapi.clust.DataCluster;
import org.phantomapi.clust.Keyed;
import org.phantomapi.clust.Tabled;
import org.phantomapi.construct.Controllable;
import org.phantomapi.construct.Controller;
import org.phantomapi.construct.Ticked;

@Tabled("table_name")
@Ticked(0)
public class ExampleController extends Controller implements Configurable
{
    //Define it as PUBLIC and fill in the value
    @Keyed("some.name")
    public String someName = "Some Value";
    
    //Comment your fields
    @Comment("This is a \nMultiline Comment")
    @Keyed("some.value")
    public int someVal = 665;
    
    @Comment("Wrappers can be used aswell")
    @Keyed("some.wrapper")
    public Double someWrapper = 3.54543452;
    
    private DataCluster cc;
    
    public ExampleController(Controllable parentController)
    {
        super(parentController);
        
        cc = new DataCluster();
    }
    
    @Override
    public void onStart()
    {
        //Load via SQL
        loadMysql(this);
        
        //Or Save it
        saveMysql(this);
    }
    
    @Override
    public void onStop()
    {
        
    }
    
    @Override
    public void onTick()
    {
        
    }

    @Override
    public void onNewConfig()
    {
        // Dynamic (not using it)
    }

    @Override
    public void onReadConfig()
    {
        // Dynamic (not using it)
    }

    @Override
    public DataCluster getConfiguration()
    {
        return cc;
    }

    @Override
    public String getCodeName()
    {
        return "config";
    }
}
```

## DataHandlers
When there is a need for multiple configurable objects of the same type to be cached and bound to another unique type of object, DataHandlers are your friend. Here is how it works

![](Capture.PNG)

Lets make the data handler. Keep in mind, we will need to implement how to load and save the data. The rest is handled for us. Even if you request an object that isnt cached, it will be looked up, if it isnt found it will even create the defaults and load it in that way returning the configurable object. This is typically helpful when making playerdata.

### The PlayerData Object
The playerdata object will store our player's data for us and deal with basic functionality if we choose to.

``` java
package org.phantomapi.example;

import org.bukkit.entity.Player;
import org.phantomapi.clust.Configurable;
import org.phantomapi.clust.DataCluster;
import org.phantomapi.clust.Keyed;
import org.phantomapi.clust.Tabled;

//This is not needed for yml configs, but
//In case we ever choose to use SQL, its here
@Tabled("player_title_data")
public class PlayerData implements Configurable
{
    private Player player;
    private DataCluster cc;
    
    @Keyed("cool.title")
    public String cooTitle = "Title";
    
    public PlayerData(Player player)
    {
        this.player = player;
        this.cc = new DataCluster();
    }
    
    @Override
    public void onNewConfig()
    {
        // Dynamic
    }

    @Override
    public void onReadConfig()
    {
        // Dynamic
    }

    @Override
    public DataCluster getConfiguration()
    {
        return cc;
    }

    @Override
    public String getCodeName()
    {
        //This makes each config from this type different 
        //Based on the player's uuid.
        return player.getUniqueId().toString();
    }
    
}
```

### The Data Handler
Lets create a controller for this. Since we need to know what to do when to stop, and what to do when we start. More specifically there are a set few helpers for this. We will be using the DataHandler which is actually a controller by itself.

``` java
package org.phantomapi.example;

import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.player.PlayerQuitEvent;
import org.phantomapi.clust.DataController;
import org.phantomapi.construct.Controllable;

//Notice we add <PlayerData, Player>
//This means we want the configurable object to be PlayerData.class
//And we want the identifier to be a Player.class type
public class PlayerDataController extends DataController<PlayerData, Player>
{
    public PlayerDataController(Controllable parentController)
    {
        super(parentController);
    }

    @Override
    public PlayerData onLoad(Player identifier)
    {
        //This is called when we need to load a playerdata instance
        //We are given a player identifier
        
        PlayerData pd = new PlayerData(identifier);
        loadCluster(pd);
        
        return pd;
    }

    @Override
    public void onSave(Player identifier)
    {
        //Called when we need to save a player
        //We can use the get() method to get it from the cache
        
        saveCluster(get(identifier));
    }

    @Override
    public void onStart()
    {
        
    }

    @Override
    public void onStop()
    {
        //To save all of the data in the cache
        saveAll();
    }
    
    @EventHandler
    public void on(PlayerQuitEvent e)
    {
        //Save the player when they quit
        save(e.getPlayer());
    }
}
```
Do not load clusters. There is no need to. Since when you call get(Player) if its not cached, it will be loaded and returned. Just be sure to save it onStop() and on player quits

# Async Configurables
###### Best for very large to massive data cluster sizes

The simplest way to make your configurable objects to load async is by annotating it with AsyncConfig. This will tell phantom to async load your config. However, you must use the onReadConfig() for when it is loaded in. Using onStart() does not guaranteeee that the config has loaded yet.

``` java
package org.phantomapi;

import org.phantomapi.clust.AsyncConfig;
import org.phantomapi.clust.ConfigurableObject;
import org.phantomapi.clust.Keyed;
import org.phantomapi.util.D;

@AsyncConfig
public class BasicConfig extends ConfigurableObject
{
    @Keyed("some.key")
    public boolean value = false;
    
    public BasicConfig()
    {
        super("config");
    }
    
    @Override
    public void onReadConfig()
    {
        new D("Log").s("The configuration has finished loading async");
    }
}
```

Note that in this example, the configuration is not loaded by this object. We must load it in with a controller. This can create some confusion in knowing when the object has actually finished loading it's data. We can simply make an isLoaded() method. 

# Commands
###### Create command listeners without limit
You can handle commands on a separate layer if you wish while using phantomapi. This layer works above the bukkit command api, allowing you to override all bukkit commands before they touch other plugins. Here are some benefits while using phantom command regristry.
* Dynamic Registry and Unregistry
* Dynamically create aliases and change them anytime
* No configuration with the plugin.yml file
* Command Filters and messaging handled before it hits your listener
* Custom Command sender for RawText, Tags, and MessageProviders

## Creating a Command Controller
Lets create the most basic CommandController without handling anything. 
``` java
package org.phantomapi.example;

import org.phantomapi.command.CommandController;
import org.phantomapi.command.PhantomCommand;
import org.phantomapi.command.PhantomCommandSender;
import org.phantomapi.construct.Controllable;

public class CommandHandler extends CommandController
{
    public CommandHandler(Controllable parentController)
    {
        super(parentController, "command-name");
    }

    @Override
    public boolean onCommand(PhantomCommandSender sender, PhantomCommand command)
    {
        return false;
    }

    @Override
    public void onStart()
    {
        
    }

    @Override
    public void onStop()
    {
        
    }
}
```

Controller registry handles command registry, however you can dynamically re-register them if need be. 

## Hotdrop Command Listeners
In any controller you can now hotdrop methods as command listeners with filters. 

``` java
package org.phantomapi;

import org.phantomapi.command.Command;
import org.phantomapi.command.CommandFilter;
import org.phantomapi.command.PhantomCommand;
import org.phantomapi.command.PhantomSender;
import org.phantomapi.construct.Controllable;
import org.phantomapi.construct.Controller;

public class BasicController extends Controller
{
    public BasicController(Controllable parentController)
    {
        super(parentController);
    }

    @Override
    public void onStart()
    {
        
    }

    @Override
    public void onStop()
    {
        
    }
    
    @Command("testing")
    @CommandFilter.PlayerOnly
    @CommandFilter.Permission("test.green")
    @CommandFilter.SubCommands("green")
    public void onCommandGreen(PhantomSender sender, PhantomCommand cmd)
    {
        //Fires this when a player with the permission test.green
        //uses the command /testing green
    }
    
    @Command("testing")
    @CommandFilter.ConsoleOnly
    @CommandFilter.SubCommands("red")
    public void onCommandRed(PhantomSender sender, PhantomCommand cmd)
    {
        //Fires this when a console
        //uses the command /testing red
    }
}
```

# Command Aliases
###### Reregister command aliases with ease
Command aliases are registered by overriding the getCommandAliases() method. 

## Defining Aliases
If these are ever changed, you will need to re-register the command controller from the command registery explained below.
``` java
    @Override
    public GList<String> getCommandAliases()
    {
        return new GList<String>().qadd("set").qadd("of").qadd("aliases");
    }
```

## Dynamic Aliases & Re-Registry
Re-registering is simple. Just make sure you have modified your aliases (field variable) before re-registering. 

``` java
//Fired from the CommandController in previous examples
Phantom.instance().getCommandRegistryController().unregister((CommandListener) this);
Phantom.instance().getCommandRegistryController().register((CommandListener) this);
```

# Command Filtering
###### Less checking, more doing.
You can also filter your commands and have the command bus automatically message the player about the issue. The event is never fired and you dont have to deal with handling simple things

## List of filters
* ArgumentRange(from, to)
* ComsoleOnly
* OperatorOnly
* Permission("required.to.use.this)
* Permissions("needs.this", "and this", ...)
* PlayerOnly
* Subcommands("must", "be", "ordered", ...)

## Using Command Filters
Command filters are used as annotations above the command event
``` java
    @CommandFilter.PlayerOnly
    @CommandFilter.ArgumentRange({0, 1})
    @CommandFilter.Permission("plugin.god")
    public boolean onCommand(PhantomCommandSender sender, PhantomCommand command)
    {
        //This will only fire if the following match
        /*
         * The sender must be a player
         * The sender must have from 0-1 arguments
         * The sender must have the permission "plugin.god"
         */
        
        return false;
    }
```

# Tag Building & Messaging
###### Send messages without having to color and tag each one
Sometimes creating your own tags and using them in all response messages either get left out or are a pain. Especially with RawText. Here is a simple way to define your tags.

## Define Tags
There are two ways to define tags within a command controller. First being overriding methods, and the second is by handling them when the command event is fired.

### Override
``` java
//Within the command Controller from the previous example
    @Override
    public String getChatTag()
    {
        return C.DARK_GRAY + "[" + C.RED + "TAG" + C.DARK_GRAY + "]: ";
    }
    
    @Override
    public String getChatTagHover()
    {
        return C.RED + "Plugin name? Version?";
    }
```

### Realtime
``` java
//Within the command controller from the previous example
    @Override
    public boolean onCommand(PhantomCommandSender sender, PhantomCommand command)
    {
        //Create a new message builder
        MessageBuilder mb = new MessageBuilder();
        
        //Just the tag
        mb.setTag(C.DARK_GRAY + "[" + C.RED + "TAG" + C.DARK_GRAY + "]: ");
        
        //or the hover also.
        mb.setTag("tag", "hover");
        
        //Change the message builder. JUST THIS COMMAND EVENT. 
        //Its recreated each time its fired
        sender.setMessageBuilder(mb);
        
        //Process command here
        sender.sendMessage("message will be tagged");
        
        return false;
    }
```

# Effects
###### Nested effects like controllers nest
There are plenty of ways to play effects within phantom weather it be visual, or auditory. They all follow the same abstract design of stacking just like controllers (but not controllers)

![](Capturefx.PNG)

By using this design, not only can you reproduce the same effect in different places with different properties, but small effects in the modular effect can be tweaked or even dynamically changed any time.

# Visual Effects
###### Stunning effects designed with ease.
Visual effects can be created very simply as described below.

# Basic Visual Effect
``` java
VisualEffect effect = new PhantomEffect()
{
    @Override
    public void play(Location location)
    {
        //Play your new effect here... You can do anything you like
        ParticleEffect.CLOUD.display(1f, 1f, 1f, 0.5f, 1, location, 12);
    }
};

//Now you can use this anytime
effect.play(Bukkit.getPlayer("cyberpwn").getLocation());
```

# Particle Manipulators
Allows extra processing to use your effect. Lets make a line with our effect above

![](http://i.imgur.com/rZUSOUi.png)

Lets make it
``` java
//Our old effect
VisualEffect effect = new PhantomEffect()
{
    @Override
    public void play(Location location)
    {
        //Play your new effect here... You can do anything you like
        ParticleEffect.CLOUD.display(1f, 1f, 1f, 0.5f, 1, location, 12);
    }
};

//Lets play our old effect across a line!
VisualEffect line = new LineParticleManipulator()
{
    @Override
    public void play(Location location)
    {
        //Do anything in here.
        effect.play(location);
    }
};

//Draw the line!
((LineParticleManipulator)line).play(Location a, Location b, 1.0);
```

Remember lines are visual effects, so they can be played in other effects!

# Audio Effects
###### Punchy sound effects
The GSound is an object that can hold a sound from a Sound enum or a string, with volume and pitch information
``` java
//Default pitch and volume if not supplied
GSound sound = new GSound(Sound.CLICK); 

//Resource pack sounds
GSound resourcePackSound = new GSound("custom.sound.location", 1f, 1f);

//can play to a single player
sound.play(Player p);

//can play to a single player from a location
sound.play(Player p, Location l);

//can play to a single player from a location relative to player
sound.play(Player p, Vector v);

//can play to all nearby players
sound.play(Location l);
```

## Stacking Audible Objects
You can take a gsound and put it next to 3 others to make something unique but play it with one object.
``` java
//Create two sounds that could go together
Audible a = new GSound(Sound.CLICK, 1f, 0.4f);
Audible b = new GSound(Sound.BAT_TAKEOFF, 1f, 1.4f);

//Create a new "Audio object"
Audible c = new Audio();

//Add our sounds from above
((Audio)c).add(a);
((Audio)c).add(b);

//Play the sound c
c.play(Bukkit.getPlayer("cyberpwn"));
```

# Super Stacking (Usage Example)
Lets make a really bad sound

![](http://i.imgur.com/TOUsVvh.png)

Now lets implement it

``` java
//Create Some low sounds
Audible explosion = new GSound(Sound.EXPLODE, 1f, 0.4f);        
Audible subBass = new GSound(Sound.WITHER_SPAWN, 0.6f, 0.6f);

//Create Some high sounds
Audible shatter = new GSound(Sound.GLASS, 1f, 1.6f);
Audible flap = new GSound(Sound.BAT_TAKEOFF, 1f, 1.5f);

//Make a "low audible"
Audible low = new Audio();
((Audio)low).add(explosion);
((Audio)low).add(subBass);

//Make a "high audible"
Audible high = new Audio();
((Audio)high).add(shatter);
((Audio)high).add(flap);

//Make the "global sound package"
Audible sound = new Audio();
((Audio)sound).add(high);
((Audio)sound).add(low);
((Audio)sound).add(new GSound(Sound.CLICK)); //why not?

sound.play(Bukkit.getPlayer("cyberpwn"));
```

# World Artifacts & Structures
###### Artifacts, Schematics all built async
World structuring works just like the effect model shown here

![](Capturefx.PNG)


# Schematics
###### World data to be manipulated and placed many times
Schematics hold block information within a dimension.

# Schematic manipulation
``` java
//Lets make a 3x3x3 cube dimension
Dimension dimm = new Dimension(3, 3, 3);

//Create an empty schematic
Schematic schem = new Schematic(dimm);
    
//Fill it all with cobblestone
schem.fill(new MaterialBlock(Material.COBBLESTONE));

//Set the center block to air
schem.set(1, 1, 1, Material.AIR, (byte)0);

//Replace cobblestone with cobblestone and stone randomly
RandomDistortion dist = new RandomDistortion(new MaterialBlock(Material.COBBLESTONE), new MaterialBlock(Material.COBBLESTONE), new MaterialBlock(Material.STONE));
dist.onDistort(schem);

//Replace all stone with glowstone
schem.replace(new MaterialBlock(Material.STONE), new MaterialBlock(Material.GLOWSTONE));

//Remove the top layer
schem.setFace(new MaterialBlock(Material.AIR), Direction.U);

//Build it in the world (5 blocks above player)
schem.apply(Bukkit.getPlayer("cyberpwn").getLocation().add(0, 5, 0));
```


# Artifacts
###### Objective regions of the world 
Artifacts can hold a schematic and location. They can be moved and placed into other artifacts. Lets make a schematic and play around with it wrapped in an artifact.

# The Artifact
``` java
//Create a schematic
Schematic pistonSchem = new Schematic(new Dimension(3, 3, 3));
pistonSchem.fill(new MaterialBlock(Material.COBBLESTONE));
pistonSchem.set(1, 1, 1, Material.AIR, (byte)0);
pistonSchem.setFace(new MaterialBlock(Material.WOOD), Direction.U);
pistonSchem.apply(Bukkit.getPlayer("cyberpwn").getLocation().add(0, 5, 0));

//Make an artifact out of the schematic template
Artifact piston = new WorldArtifact(Bukkit.getPlayer("cyberpwn").getLocation(), pistonSchem);

//Build the piston
piston.build();

//Move it
piston.move(Bukkit.getPlayer("Puretie").getLocation());

//Remove it from the world restoring old blocks in place
piston.clear();
```

You can even have multiple artifacts from the same schematic. All in different locations

# Structures
###### Objective sets of artifacts that make structures
You can make a structure which is an artifact, which can contain multiple artifacts. Since it is an artifact, you could place structures within structures.

# Build a Piston Tree
![](http://i.imgur.com/4OCj8ic.png)

``` java
// Create a schematic
Schematic pistonSchem = new Schematic(new Dimension(3, 3, 3));
pistonSchem.fill(new MaterialBlock(Material.COBBLESTONE));
pistonSchem.set(1, 1, 1, Material.AIR, (byte) 0);
pistonSchem.setFace(new MaterialBlock(Material.WOOD), Direction.U);
pistonSchem.apply(Bukkit.getPlayer("cyberpwn").getLocation().add(0, 5, 0));

// Make 3 pistons
Artifact piston1 = new WorldArtifact(Bukkit.getPlayer("cyberpwn").getLocation(), pistonSchem);
Artifact piston2 = new WorldArtifact(Bukkit.getPlayer("cyberpwn").getLocation(), pistonSchem);
Artifact piston3 = new WorldArtifact(Bukkit.getPlayer("cyberpwn").getLocation(), pistonSchem);

// Create an artifact holder for all the pistons
Artifact pistonTree = new WorldStructure(Bukkit.getPlayer("cyberpwn").getLocation());

//Add artifacts in different relations
((WorldStructure) pistonTree).add(piston1, new Vector(0, 4, 0));
((WorldStructure) pistonTree).add(piston2, new Vector(0, 8, 0));
((WorldStructure) pistonTree).add(piston3, new Vector(0, 12, 0));

//Builds it
pistonTree.build();

//Moves all the sub-artifacts
pistonTree.move(Bukkit.getPlayer("Puretie").getLocation());

//Restores all modified blocks and removes it from the world until built
pistonTree.clear();
```

# Scheduling
###### Quick tasks
No one likes task id's, but everyone probably has tried to cancel a task within a runnable.... ehem final single index array int... Not pretty. Lets fix that for good.
* See [Task](http://phantomapi.org/docs/org/phantomapi/sync/Task.html)
* See [TaskLater](http://phantomapi.org/docs/org/phantomapi/sync/TaskLater.html)

``` java
package org.cyberpwn.phantom;

import org.cyberpwn.phantom.sync.Task;
import org.cyberpwn.phantom.sync.TaskLater;

public class Example
{
    public Example()
    {
        //Schedule a repeating task.
        new Task(0)
        {
            public void run()
            {
                //You can cancel it in here also
                cancel();
                
                //You can check if its running (this is for outside of here)
                isRunning();
            }
        };
        
        //Schedule a delayed task.
        new TaskLater(20)
        {
            public void run()
            {
                //Bam (fires one second into the future)
            }
        };
    }
}
```

# Executive Tasks
###### Aggressive handovers made easy.
# Executive Iterators
Executive Iterators allow you to run a normal iterator, but attach a runnable to it, and pass the "next()" value into the runnable with each iteration.
* See [ExecutiveIterator](http://phantomapi.org/docs/org/phantomapi/sync/ExecutiveIterator.html)
* See [ExecutiveRunnable](http://phantomapi.org/docs/org/phantomapi/sync/ExecutiveRunnable.html)

![](http://i.imgur.com/sCUvZi2.png)

###### Here is a basic Executive Iterator
``` java
public class Example
{
    public Example()
    {
        // Create the Executive Iterator
        //We also pass in a list of players,
        //We then pass in a runnable to handle all the players
        GList<Player> players = Phantom.instance().onlinePlayers();
        ExecutiveIterator<Player> it = new ExecutiveIterator<Player>(players)
        {
            public void onIterate(Player next)
            {
                Player p = next;
                
                p.sendMessage("Message from an Executive");
            }
        };
        
        //You can also initialize it from a GList<Player>
        Phantom.instance().onlinePlayers().iterator(new ExecutiveRunnable<Player>()
        {
            public void run()
            {
                Player p = next();
                
                p.sendMessage("Message from an Executive");
            }
        });
        
        //Lets Iterate
        while(it.hasNext())
        {
            //Executes your runnable and returns the player executed.
            it.next();
        }
    }
}
```

# Executive Tasks
Now, we can take an executiveIterator and run it through a special task. This task can be passed in a limit in milliseconds. Essentially, the task will run each iteration in your iterator as fast as possible, but will stop after it takes up the limit of milliseconds, and wait to the next tick to resume iterating through your task.

![](http://i.imgur.com/jZdbPlo.png)

``` java
package org.cyberpwn.phantom.construct.test;

import org.bukkit.entity.Player;
import org.cyberpwn.phantom.Phantom;
import org.cyberpwn.phantom.sync.ExecutiveIterator;
import org.cyberpwn.phantom.sync.ExecutiveRunnable;
import org.cyberpwn.phantom.sync.ExecutiveTask;

public class Example
{
    public Example()
    {
        //Lets make a list of players again.
        ExecutiveIterator<Player> it = Phantom.instance().onlinePlayers().iterator(new ExecutiveRunnable<Player>()
        {
            public void run()
            {
                Player p = next();
                
                p.sendMessage("Message from an Executive");
            }
        });
        
        //Lets iterate it with a limit of 0.1ms (100k nanoseconds)
        //We will add in the iterator and define a finish runnable
        //The 0 is the interval in ticks
        new ExecutiveTask<Player>(it, 0.1, 0, new Runnable()
        {
            @Override
            public void run()
            {
                //The Executive Task has finished running.
                //This is called when the task has finished
            }
        });

        //You could also just tell phantom to handle it
        Phantom.schedule(it);
        
        //You can even assign it to a channel
        //Warning, each channel has 1ms allocated.
        //Too many channels could actually cause high ms
        Phantom.schedule("your-own-channel", it);
    }
}
```

# Transmission
###### Reliable bungeecord
The transmission api allows you to communicate across the bungeecord proxy with ease and simplicity. Here are some benefits to using the Transmission API
* If the Source and Destination servers dont have at least one player, it will be queued to send until the conditions are met for a safe transmission
* Transmission packets use packet compression
* Transmission packets are data clusters. You can store vast types of data in them.
* Transmission packets store several identifiers 
  * A Destination of where to go
  * A Source of where it came from
  * A Timestamp for when it was sent
  * A TYPE which is used for parsing the data on the destination server

![](transmit.png)
# Transmitting Packets
Sending packets are the simplest, and have the most "will it actually go through" security since the destination ends are checked.

``` java
//Creates a transmission to be sent to ALL servers
Transmission t = new Transmission("packet-type");

//You can also set the specific destination
t = new Transmission("packet-type", "specific-server");

//Add some data
t.set("some.boolean", false);
t.set("some.string", "FooBar");
t.set("some.list", Phantom.instance().onlinePlayers().toString(", "));        

//Transmit it!
try
{
    t.transmit();
}
catch(IOException e)
{
    e.printStackTrace();
}
```

# Receiving Transmissions
Receiving transmitters are simple aswell. Just ensure you 
* Implement Transmitter
* Register it
* Listen on the Transmit method

``` java
package org.phantomapi.example;

import java.util.List;
import org.phantomapi.Phantom;
import org.phantomapi.construct.Controllable;
import org.phantomapi.construct.Controller;
import org.phantomapi.lang.GList;
import org.phantomapi.transmit.Transmission;
import org.phantomapi.transmit.Transmitter;

public class ExampleController extends Controller implements Transmitter
{
    public ExampleController(Controllable parentController)
    {
        super(parentController);
    }
    
    @Override
    public void onStart()
    {
        //Register the Transmitter
        Phantom.registerTransmitter(this);
    }
    
    @Override
    public void onStop()
    {
        
    }

    @Override
    public void onTransmissionReceived(Transmission t)
    {
        //Check if the type is correct
        if(t.getType().equals("packet-type"))
        {
            //Who sent it?
            t.getSource();
            
            //When did they send it?
            t.getTimeStamp();
            
            //Get the data we sent
            Boolean someBoolean = t.getBoolean("some.boolean");
            String fooBar = t.getString("some.string");
            List<String> list = t.getStringList("some.list");
        }
    }
}
```

# Phantom Network
###### Get network information without waiting and sending
Phantom has abstracted the entire bungeecord network for ease of use when getting servers and players within them

``` java
//Get the network instance
Network net = Phantom.getBungeeNetwork();

//Get the server instance of THIS server
NetworkedServer thisServer = net.getLocalServer();

//Get a remote server by name
NetworkedServer grushServer = net.getRemoteServer("glacialrush");

//Get all players on the entire network
net.getPlayers();

//Get all the networked servers
for(NetworkedServer i : net.getServers())
{
    if(i.isRemote())
    {
        //This networked server is remote
        //This server is not the current server (local)
        
        //Get the name of this server
        i.getName();
        
        //Get the players on this server
        i.getPlayers();
        
        //Send a player on the local server to this remote server
        i.sendPlayer(Player);
    }
    
    else
    {
        //The server i is equal to the local server THIS ONE
    }
}
```

# Asynchronous Processing
###### Dive in and out of async quickly
With the phantom task manager with help from FAWE aswell, we have the simplest task manager. This can be used anywhere.
``` java
new A()
{
    @Override
    public void async()
    {
        //Welcome to a new async thread
        D d = new D("Async Dispatcher");
        d.s("This is async");
        
        new S()
        {
            @Override
            public void sync()
            {
                d.s("This is sync");
            }
        };
        
        d.s("Back to async");
    }
};
```

# Multithreaded Processing
###### Fast multithreaded processing
Creating a multithreaded executor, you only really need three things to begin processing data with multiple threads.
* A Data type for the threaded queue (This example uses strings)
* Queue the data
* Actively dispatch threads by invoking dispatch();

``` java
// Set up a queue of strings with a max of 4 threads
MultithreadedQueueExecutor<String> queue = new MultithreadedQueueExecutor<String>(4)
{
    @Override
    public void onProcess(String t)
    {
        // This is called async when something is processed
        t.toLowerCase().toUpperCase().toLowerCase().toCharArray();
    }
};

// Queue stuff
for(int i = 0; i < 1024; i++)
{
    queue.queue(UUID.randomUUID().toString());
}

// Tick it 20 times a second (or less?)
new Task(0)
{
    @Override
    public void run()
    {
        //We wont be constantly piling on the queue
        //Might aswell stop ticking it when finished
        if(queue.getQueue().isEmpty())
        {
            cancel();
            return;
        }
        
        // Dispatch new threads if there are any
        queue.dispatch();
    }
};
```

# Asynchronous World
###### The world, unlocked
With phantom, strapped with FAWE, all world modifications are handled async anyways through FAWE, however we have added some useful utilities so you don't have to add all of the dependencies for FAWE and reconfigure your environment.

## Getting the Async World
This retreives the async world implementation by FAWE, you can modify this async or sync.

``` java
new A()
{
    @Override
    public void async()
    {
        World world = W.getAsyncWorld("world_name");
        world.getBlockAt(0, 0, 0).setType(Material.GLASS);
        world.getBlockAt(0, 0, 0).getChunk().getX();
    }
};
```

## Queue async modifications (while sync or async)
Most of the time, blocks need to be modified quickly without the worry of having to dive into an async task/thread for each modification. We have created a multiworld queue and a master queue for even faster handling.

### Getting a Phantom Queue
This method is safe for sync and async processing, you will need to manually flush the queue
``` java
//Get a queue for this world
PhantomWorld world = new PhantomWorld(Bukkit.getWorld("world"));
PhantomEditSession queue = new PhantomEditSession(world);

//Set and get things (async or sync)
queue.set(world.getBlockAt(0, 0, 0).getLocation(), Material.GLASS);

//Flush when you are finished
queue.flush();
```

### Getting a Phantom World Queue
This method can queue any world without having to supply the world. The world queue is supplied and created within this queue when it is modified.

``` java
//Just using a world as an example
//Since we dont have a location
World world = Bukkit.getWorld("world");

//No need to supply a queue
PhantomWorldQueue queue = new PhantomWorldQueue();

//Queue stuff
queue.set(world.getBlockAt(0, 0, 0).getLocation(), Material.ACACIA_DOOR);

//Flush when complete
queue.flush();
```

### Queue to the MasterQueue
There is an even quicker way to queue changes to the world sync or async. However this auto queues, meaning multithreaded modifications may look weird while applying it. The queue is flushed 20 times a second.

``` java
// Just using a world as an example
// Since we dont have a location
World world = Bukkit.getWorld("world");

EditSessionController.queue(world.getSpawnLocation(), new MaterialBlock(Material.GLASS));
```

### Relight Chunks
Relighting chunks is very simple. Relighting the same chunk with different blocks will only relight the chunk once. It is relit async on a queue every second. 

``` java
//Relight a chunk from a block (multiple relights will be merged)
Photon.relight(Block);

//Relight by chunk
Photon.relight(Chunk);

//Relight by location (entire chunk is relit)
Photon.relight(Location);
```

# Wraiths
###### Simple, yet powerful NPC API
The Wraith api allows you to create and control player npc's with simple concepts or even more complex Wraiths with handlers and ai controllers. It's all possible with the WRAITH api in phantom

## Create a Basic Wraith
Let's play around with some simple functionality through wraiths to get started

``` java
//Create the Wraith and give it a name
Wraith wraith = new PhantomWraith("Wraith");

//Let's spawn the wraith into the world so we can use it
wraith.spawn(Bukkit.getWorld("world").getSpawnLocation());

//You can follow entities or locations
wraith.setTarget(Bukkit.getPlayer("cyberpwn"));

//You can "focus" on entities or locations
wraith.setFocus(Bukkit.getPlayer("SwiftSwamp"));

//You can equip wraiths with items
wraith.setEquipment(WraithEquipment.HAND, new ItemStack(Material.IRON_SWORD));
wraith.setEquipment(WraithEquipment.CHESTPLATE, new ItemStack(Material.GOLD_BOOTS));

//Or all of this
wraith.setAggressive(true);
wraith.setSneaking(true);
wraith.setSprinting(false);
wraith.setTarget(Bukkit.getPlayer("Herobrine"));
wraith.setFocus(Bukkit.getPlayer("Herobrine"));
wraith.setProtected(true);
wraith.say("I will kill you Herobrine", 32);

//When you are done
wraith.despawn();
```

#### Wraith Events
* WraithCollideEvent - **An entity collided with the wraith**
* WraithDamageEvent - **The wraith was damaged by an entity or block**
* WraithInteractEvent - **A Player right clicked the wraith**
* WraithMoveEvent - **The wraith has moved**

## Wraith Handlers
Wraith handlers allow you to control a wraith and use it across multiple wraiths if need be. 

``` java
package org.phantomapi;

import org.phantomapi.wraith.Wraith;
import org.phantomapi.wraith.WraithHandle;

public class ExampleHandler extends WraithHandle
{
    public ExampleHandler(Wraith wraith)
    {
        super(wraith);
        
        // Set up any data for the wraith
    }
    
    @Override
    public void onTick()
    {
        // Called 4 times a second
    }
    
    @Override
    public void onUnbind()
    {
        // Called before the handler is removed from the wraith
    }
    
    @Override
    public void onBind()
    {
        // Called when the handler is added to the wraith
    }
}
```

You can then add the handler like so

``` java
Wraith w = new PhantomWraith("Wraith");

//This automatically binds the handle
ExampleHandler handle = new ExampleHandler(w);

//You can remove it internally or from here
handle.unregister();

//Destroys handlers
w.despawn();
```

# SlateAPI Scoreboards
Scoreboards can sometimes be a pain without using any wrappers or apis, however, SlateAPI may have some extra things that can help the process even easier.

## Basic Slates
A Basic slate scoreboard consists of
* A Name (changable)
* A List of Lines
* A List of Viewers (players)

``` java
//Create a slate
Slate s = new PhantomSlate(C.RED + "Slate Name");

//Add a viewer
s.addViewer(Bukkit.getPlayer("cyberpwn"));

//Add a line or two
s.addLine(C.RED + "Level: Nether");
s.set(0, C.RED + "Level: Overworld");

//Change the name
s.setName(C.BLUE + "New Name");

//Clear all lines
s.clearLines();

//Bulk set lines
s.setLines(new GList<String>().qadd("Line").qadd("Line 2"));

//Update it
s.update();
```

## Placeholder Slates
Now you can hook into placeholders very simply or use it for loading from configuration files
``` java
Slate s = new PlaceholderSlate(C.RED + "Slate");

//Placeholders are automatically updated with update()
s.addLine("This is a %parsed_placeholder%");
s.addViewer(Bukkit.getPlayer("cyberpwn"));
s.update();
```

# Stacks (Items & Inventories)

The stack api allows direct access to the inventory items by thrashing it's changes to the actual inventory. all items are not cloned when "getting the list". 

## The Stack
``` java
//Just like an item stack
Stack stack = new Stack(Material.GLASS);
stack.setAmount(4);
stack.setName(C.RED + "Custom name");
stack.setData((byte) 0);
stack.setLore(new GList<String>().qadd("This is lore").qadd("This is too"));
stack.getEnchantmentSet().addEnchantment(Enchantment.DURABILITY, 1337);
stack.setDurability((short) 0);
stack.setPotionData(new PotionData(false, 4, new GList<PotionEffect>()));
```

## The Stacked Inventory
``` java
Player p = Bukkit.getPlayer("cyberpwn");

//Get a stacked inventory
StackedInventory inventory = new StackedInventory(p.getInventory());

//Get a direct NON CLONED list of items
inventory.getStacks().remove(3);

//Directly stack them
inventory.setStacks(new GMap<Integer, Stack>().qput(0, new Stack(Material.GLASS)));

//Thrash when done
inventory.thrash();
```

# Utilities
Utilities are always an important thing when trying to get things done quickly. Here are all of the notable utilities and how to use them effectively

## General Utilities
Here's the generic crap you never need until you need it

#### Timers
Time execution with the timer
``` java
T timer = new T()
{
    @Override
    public void onStop(long nsTime, double msTime)
    {
        s("Took " + msTime + "ms");
    }
};

timer.start();

//Do something

timer.stop(); //onStop was called
```

#### Basic Formatting
There are loads of formatting, utilities in the F class
``` java
//Comma format
F.f(1024); // returns "1,024"

//Format decimals
F.f(43.66666, 2); // returns "43.67"

//File sizes
F.fileSize(1024l); // returns "1 KB"

//Color back to bukkit characters 
F.color("&cRed Text");

//Percents
F.pc(0.44455); //returns "44%"
F.pc(0.44455, 2); //returns "44.46%"
```

## NMS Utilities
NMS Utilities rely on reflection based on the version of the server and offer loads of helpful things that may be needed.
#### Particle Effects
Particle effects run on DarkBlade12's particle effect class, however, we've added some things to it and tweaked it a bit over time. 
###### [All Particle Effects](http://cyberpwnn.github.io/Phantom/org/phantomapi/vfx/ParticleEffect.html)
``` java
ParticleEffect.FIREWORKS_SPARK.display(0f, 0, Location, 24);
```
#### Pinging Players
Pinging can't get any simpler
``` java
NMSX.ping(Player);
```

#### Sleeping Animation
Play sleeping animation of a player to all nearby players
``` java
//Start sleeping animation
NMSX.playSleepAnimation(Player);

//Stop sleeping animation
NMSX.stopSleepAnimation(Player);
```

#### Play Records
Play records to players easily
``` java
NMSX.playRecord(Player, Material.RECORD_12);
```

#### Hide and Show Entities
You can show and hide entities via packets just like vanish. They will no longer exist to the client viewer
``` java
NMSX.hideEntity(Player viewer, Entity hide);
NMSX.showEntity(Player viewer, Entity show);
```

#### Launch Fireworks
You can launch fireworks very simply with color and different types
``` java
NMSX.launchFirework(Location);
NMSX.launchFirework(Location, Color);
NMSX.launchFirework(Location, Color, FireworkEffect.Type.BURST);
NMSX.launchFirework(Location, Color, Color, FireworkEffect.Type.CREEPER);
```

#### Pick Up Animation
You can show a pickup animation from any entity to any entity. A baby zombie could pick up a giant zombie in the perspective of the viewer 

**WARNING! The picked up entity will vanish but can still interact with the player who doesnt see it. The entity can even be heard and can damage you.**
``` java
NMSX.showPickup(Player viewer, Entity entity, Entity pickedUp);
```
#### Show Demo Screen
Could prove useful for resource packed games
``` java
NMSX.showDemo(Player);
```

#### Show End Credits
You can show the end credits to a player
``` java
NMSX.showEnd(Player);
```

#### Change Weather Intensity
You can now change the weather intensity by changing brightness states
``` java
//0-1 (0 is normal) (1 is raining)
//Anything higher is simply LSDPCPPsilosybin
NMSX.showWeather(Player, 0f);
```

#### Tab Header and Footer
You can easily change the tablist header and footer
``` java
NMSX.sendTabTitle(Player, "tab header\ndoubleline", "tab footer\ndoubleline");
```

#### Change Block Break Animation level
you can change the block break animation level for a player. Use levels 0-9 to go through the texture index for break levels. Setting this to any other value outside of 0-9 will reset it to none.
``` java
NMSX.showBlockBreakAnimation(Player, Location, 0);
```

#### Title Messages
Send title messages with the title wrapper. You can construct all of this data, but in this example, the method setters are used
``` java
Title title = new Title();
title.setAction("Action bar!");
title.setSubTitle("Subtitle");
title.setTitle("Title");
title.setStayTime(4);
title.setFadeIn(2);
title.setFadeOut(300);

title.send(Player);
```

## World Utilities
Worldly utilities all in the W class

#### Get Async World
You can get an async safe world like so
``` java
World world = W.getAsyncWorld("world");
```

#### Get a radius of chunks
Very simple to do
``` java
//Get a 3x3 set of chunks with the given chunk as the center
GList<Chunk> chunks = W.chunkRadius(Chunk, 1);
```

#### Get Border chunks
Get all the bordering chunks for the given chunk
``` java
GList<Chunk> chunks = W.chunkFaces(Chunk);
```

#### Get Border Blocks
Get all blocks touching the given block (every block, even air)
``` java
GList<Block> blocks = W.blockFaces(Block);
```

#### Difference in Vectors
Get a value difference in vectors
``` java
Double diff = W.differenceOfVectors(Vector, Vector)
```

#### Get MaterialBlock from String
Get a material with data from a given string
``` java
W.getMaterialBlock("Stone:5");
W.getMaterialBlock("4");
W.getMaterialBlock("1:4");
W.getMaterialBlock("comPASS");
```

#### Get Entity looking at Entity
Get an entity that a given entity is looking at or null
``` java
//Get the entity that the given entity is looking at
//Max range is 12
//Difference offset is 1.5 (can look away up to 1.5 blocks as padding)
W.getEntityLookingAt(Entity, 12, 1.5);
```

#### Get World Edit Selection
Get the cuboid world edit selection 
``` java
//Cuboid selection from worldedit
Cuboid c = W.getSelection(Player)
```

#### Get Sync World from Async World
Make sure this is used on the main thread
``` java
W.getSyncWorld(World asyncOrSyncWorld);
```

#### Potion Effects
Quickly apply potion effects
``` java
//Apply a Potion Effect of Blindness with an amp of 4 and a duration of 500 ticks
//Then apply it to the given entity
PE.BLINDNESS.a(4).d(500).c(LivingEntity);
```

#### Raytracing
Simply ray race like so
``` java
new RayTrace(Location start, Vector direction, Double maxDist, Double step)
{
    @Override
    public void onTrace(Location location)
    {
        //Called per step
    }
}.trace();
```